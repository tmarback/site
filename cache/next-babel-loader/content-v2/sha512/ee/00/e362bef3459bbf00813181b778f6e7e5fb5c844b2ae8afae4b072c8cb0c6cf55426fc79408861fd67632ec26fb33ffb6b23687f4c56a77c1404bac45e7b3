{"ast":null,"code":"var _class, _descriptor, _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\n/* eslint-disable no-await-in-loop */\nimport { observable, runInAction } from \"mobx\";\nimport { downloadBlob } from \"../../../common/dom/downloadBlob\";\nimport { toSnakeCase } from \"../../../common/object/toSnakeCase\";\nimport { messageOf } from \"../../message/helpers/messageOf\";\nexport let BackupManager = (_class = (_temp = class BackupManager {\n  constructor(databaseManager, editorManager) {\n    this.databaseManager = void 0;\n    this.editorManager = void 0;\n\n    _initializerDefineProperty(this, \"backups\", _descriptor, this);\n\n    this.databaseManager = databaseManager;\n    this.editorManager = editorManager;\n    databaseManager.initialized.then(async () => {\n      await this.loadBackupList();\n    }).catch(() => {});\n  }\n\n  async loadBackupList() {\n    const backups = [];\n    let cursor = await this.databaseManager.database.transaction(\"backup\").objectStore(\"backup\").index(\"name\").openKeyCursor();\n\n    while (cursor) {\n      backups.push({\n        id: cursor.primaryKey,\n        name: cursor.key\n      });\n      cursor = await cursor.continue();\n    }\n\n    runInAction(() => {\n      this.backups = backups;\n    });\n  }\n\n  async getId(name) {\n    return this.databaseManager.database.transaction(\"backup\").objectStore(\"backup\").index(\"name\").getKey(name);\n  }\n\n  async loadBackup(name) {\n    const backup = await this.databaseManager.database.transaction(\"backup\").objectStore(\"backup\").index(\"name\").get(name);\n    if (!backup) return;\n    this.editorManager.set(\"messages\", backup.messages.map((_ref) => {\n      let {\n        data\n      } = _ref,\n          message = _objectWithoutProperties(_ref, [\"data\"]);\n\n      return _objectSpread(_objectSpread({}, messageOf(data)), message);\n    }));\n    this.editorManager.set(\"targets\", backup.targets);\n\n    for (const target of this.editorManager.targets) {\n      target.fetch().catch(() => {});\n    }\n  }\n\n  async saveBackup(backup) {\n    if (typeof backup === \"string\") {\n      const id = await this.getId(backup);\n      backup = {\n        id,\n        name: backup,\n        messages: this.editorManager.messages.map(message => ({\n          data: _objectSpread(_objectSpread({}, message.data), {}, {\n            files: undefined\n          }),\n          reference: message.reference\n        })),\n        targets: this.editorManager.targets.map(target => ({\n          url: target.url\n        }))\n      };\n    } else {\n      backup = _objectSpread(_objectSpread({}, backup), {}, {\n        id: await this.getId(backup.name)\n      });\n    }\n\n    if (!backup.id) delete backup.id;\n    await this.databaseManager.database.transaction(\"backup\", \"readwrite\").objectStore(\"backup\").put(backup);\n    await this.loadBackupList();\n  }\n\n  async deleteBackup(name) {\n    const id = await this.getId(name);\n    if (!id) return;\n    await this.databaseManager.database.transaction(\"backup\", \"readwrite\").objectStore(\"backup\").delete(id);\n    await this.loadBackupList();\n  }\n\n  async exportBackup(name) {\n    const backup = await this.databaseManager.database.transaction(\"backup\").objectStore(\"backup\").index(\"name\").get(name);\n    if (!backup) return;\n    const backupData = {\n      version: 7,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      backups: [backup].map((_ref2) => {\n        let {\n          id\n        } = _ref2,\n            backup = _objectWithoutProperties(_ref2, [\"id\"]);\n\n        return backup;\n      })\n    };\n    const blob = new Blob([JSON.stringify(backupData, undefined, 2), \"\\n\"], {\n      type: \"application/json\"\n    });\n    downloadBlob(blob, `${name}.json`);\n  }\n\n  async exportAll() {\n    const backups = [];\n    let cursor = await this.databaseManager.database.transaction(\"backup\").objectStore(\"backup\").openCursor();\n\n    while (cursor) {\n      backups.push(_objectSpread(_objectSpread({}, cursor.value), {}, {\n        id: undefined\n      }));\n      cursor = await cursor.continue();\n    }\n\n    const backupData = {\n      version: 7,\n      backups\n    };\n    const blob = new Blob([JSON.stringify(backupData, undefined, 2), \"\\n\"], {\n      type: \"application/json\"\n    });\n    downloadBlob(blob, \"backups.json\");\n  }\n\n  async getSafeBackupName(name) {\n    if (!(await this.getId(name))) {\n      return name;\n    }\n\n    for (let number = 1; true; number++) {\n      const proposedName = `${name} (${number})`;\n\n      if (!(await this.getId(proposedName))) {\n        return proposedName;\n      }\n    }\n  }\n\n  async importBackups(blob) {\n    let exportData = JSON.parse(await blob.text());\n\n    switch (exportData.version) {\n      case 1:\n      case 2:\n        {\n          exportData = {\n            version: 3,\n            backups: [{\n              name: exportData.name,\n              message: toSnakeCase(exportData.message)\n            }]\n          };\n        }\n      // falls through\n\n      case 3:\n        {\n          exportData = {\n            version: 4,\n            backups: exportData.backups.map((_ref3) => {\n              let {\n                message\n              } = _ref3,\n                  backup = _objectWithoutProperties(_ref3, [\"message\"]);\n\n              return _objectSpread(_objectSpread({}, backup), {}, {\n                messages: [message]\n              });\n            })\n          };\n        }\n      // falls through\n\n      case 4:\n        exportData = {\n          version: 5,\n          backups: exportData.backups.map((_ref4) => {\n            let {\n              webhookUrl\n            } = _ref4,\n                backup = _objectWithoutProperties(_ref4, [\"webhookUrl\"]);\n\n            return _objectSpread(_objectSpread({}, backup), {}, {\n              target: {\n                url: webhookUrl\n              }\n            });\n          })\n        };\n      // falls through\n\n      case 5:\n        exportData = {\n          version: 6,\n          backups: exportData.backups.map((_ref5) => {\n            let {\n              messages,\n              target\n            } = _ref5,\n                backup = _objectWithoutProperties(_ref5, [\"messages\", \"target\"]);\n\n            return _objectSpread(_objectSpread({}, backup), {}, {\n              messages: messages.map(data => ({\n                data,\n                reference: target.message\n              })),\n              target: {\n                url: target.url\n              }\n            });\n          })\n        };\n      // falls through\n\n      case 6:\n        exportData = {\n          version: 7,\n          backups: exportData.backups.map((_ref6) => {\n            var _target$url;\n\n            let {\n              target\n            } = _ref6,\n                backup = _objectWithoutProperties(_ref6, [\"target\"]);\n\n            return _objectSpread(_objectSpread({}, backup), {}, {\n              targets: [{\n                url: (_target$url = target.url) !== null && _target$url !== void 0 ? _target$url : \"\"\n              }]\n            });\n          })\n        };\n      // falls through\n\n      case 7:\n        for (const backup of exportData.backups) {\n          await this.saveBackup(_objectSpread(_objectSpread({}, backup), {}, {\n            name: await this.getSafeBackupName(backup.name),\n            id: undefined\n          }));\n        }\n\n    }\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"backups\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return [];\n  }\n})), _class);","map":null,"metadata":{},"sourceType":"module"}