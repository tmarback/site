{"ast":null,"code":"import _defineProperty from \"/home/runner/work/site/site/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"/home/runner/work/site/site/node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _initializerDefineProperty from \"/home/runner/work/site/site/node_modules/next/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"/home/runner/work/site/site/node_modules/next/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"/home/runner/work/site/site/node_modules/next/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _class, _descriptor, _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* eslint-disable no-await-in-loop */\nimport { observable, runInAction } from \"mobx\";\nimport { downloadBlob } from \"../../../common/dom/downloadBlob\";\nimport { toSnakeCase } from \"../../../common/object/toSnakeCase\";\nimport { messageOf } from \"../../message/helpers/messageOf\";\nexport let BackupManager = (_class = (_temp = class BackupManager {\n  constructor(databaseManager, editorManager) {\n    this.databaseManager = void 0;\n    this.editorManager = void 0;\n\n    _initializerDefineProperty(this, \"backups\", _descriptor, this);\n\n    this.databaseManager = databaseManager;\n    this.editorManager = editorManager;\n    databaseManager.initialized.then(async () => {\n      await this.loadBackupList();\n    }).catch(() => {});\n  }\n\n  async loadBackupList() {\n    const backups = [];\n    let cursor = await this.databaseManager.database.transaction(\"backup\").objectStore(\"backup\").index(\"name\").openKeyCursor();\n\n    while (cursor) {\n      backups.push({\n        id: cursor.primaryKey,\n        name: cursor.key\n      });\n      cursor = await cursor.continue();\n    }\n\n    runInAction(() => {\n      this.backups = backups;\n    });\n  }\n\n  async getId(name) {\n    return this.databaseManager.database.transaction(\"backup\").objectStore(\"backup\").index(\"name\").getKey(name);\n  }\n\n  async loadBackup(name) {\n    const backup = await this.databaseManager.database.transaction(\"backup\").objectStore(\"backup\").index(\"name\").get(name);\n    if (!backup) return;\n    this.editorManager.set(\"messages\", backup.messages.map((_ref) => {\n      let {\n        data\n      } = _ref,\n          message = _objectWithoutProperties(_ref, [\"data\"]);\n\n      return _objectSpread(_objectSpread({}, messageOf(data)), message);\n    }));\n    this.editorManager.set(\"targets\", backup.targets);\n\n    for (const target of this.editorManager.targets) {\n      target.fetch().catch(() => {});\n    }\n  }\n\n  async saveBackup(backup) {\n    if (typeof backup === \"string\") {\n      const id = await this.getId(backup);\n      backup = {\n        id,\n        name: backup,\n        messages: this.editorManager.messages.map(message => ({\n          data: _objectSpread(_objectSpread({}, message.data), {}, {\n            files: undefined\n          }),\n          reference: message.reference\n        })),\n        targets: this.editorManager.targets.map(target => ({\n          url: target.url\n        }))\n      };\n    } else {\n      backup = _objectSpread(_objectSpread({}, backup), {}, {\n        id: await this.getId(backup.name)\n      });\n    }\n\n    if (!backup.id) delete backup.id;\n    await this.databaseManager.database.transaction(\"backup\", \"readwrite\").objectStore(\"backup\").put(backup);\n    await this.loadBackupList();\n  }\n\n  async deleteBackup(name) {\n    const id = await this.getId(name);\n    if (!id) return;\n    await this.databaseManager.database.transaction(\"backup\", \"readwrite\").objectStore(\"backup\").delete(id);\n    await this.loadBackupList();\n  }\n\n  async exportBackup(name) {\n    const backup = await this.databaseManager.database.transaction(\"backup\").objectStore(\"backup\").index(\"name\").get(name);\n    if (!backup) return;\n    const backupData = {\n      version: 7,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      backups: [backup].map((_ref2) => {\n        let {\n          id\n        } = _ref2,\n            backup = _objectWithoutProperties(_ref2, [\"id\"]);\n\n        return backup;\n      })\n    };\n    const blob = new Blob([JSON.stringify(backupData, undefined, 2), \"\\n\"], {\n      type: \"application/json\"\n    });\n    downloadBlob(blob, `${name}.json`);\n  }\n\n  async exportAll() {\n    const backups = [];\n    let cursor = await this.databaseManager.database.transaction(\"backup\").objectStore(\"backup\").openCursor();\n\n    while (cursor) {\n      backups.push(_objectSpread(_objectSpread({}, cursor.value), {}, {\n        id: undefined\n      }));\n      cursor = await cursor.continue();\n    }\n\n    const backupData = {\n      version: 7,\n      backups\n    };\n    const blob = new Blob([JSON.stringify(backupData, undefined, 2), \"\\n\"], {\n      type: \"application/json\"\n    });\n    downloadBlob(blob, \"backups.json\");\n  }\n\n  async getSafeBackupName(name) {\n    if (!(await this.getId(name))) {\n      return name;\n    }\n\n    for (let number = 1; true; number++) {\n      const proposedName = `${name} (${number})`;\n\n      if (!(await this.getId(proposedName))) {\n        return proposedName;\n      }\n    }\n  }\n\n  async importBackups(blob) {\n    let exportData = JSON.parse(await blob.text());\n\n    switch (exportData.version) {\n      case 1:\n      case 2:\n        {\n          exportData = {\n            version: 3,\n            backups: [{\n              name: exportData.name,\n              message: toSnakeCase(exportData.message)\n            }]\n          };\n        }\n      // falls through\n\n      case 3:\n        {\n          exportData = {\n            version: 4,\n            backups: exportData.backups.map((_ref3) => {\n              let {\n                message\n              } = _ref3,\n                  backup = _objectWithoutProperties(_ref3, [\"message\"]);\n\n              return _objectSpread(_objectSpread({}, backup), {}, {\n                messages: [message]\n              });\n            })\n          };\n        }\n      // falls through\n\n      case 4:\n        exportData = {\n          version: 5,\n          backups: exportData.backups.map((_ref4) => {\n            let {\n              webhookUrl\n            } = _ref4,\n                backup = _objectWithoutProperties(_ref4, [\"webhookUrl\"]);\n\n            return _objectSpread(_objectSpread({}, backup), {}, {\n              target: {\n                url: webhookUrl\n              }\n            });\n          })\n        };\n      // falls through\n\n      case 5:\n        exportData = {\n          version: 6,\n          backups: exportData.backups.map((_ref5) => {\n            let {\n              messages,\n              target\n            } = _ref5,\n                backup = _objectWithoutProperties(_ref5, [\"messages\", \"target\"]);\n\n            return _objectSpread(_objectSpread({}, backup), {}, {\n              messages: messages.map(data => ({\n                data,\n                reference: target.message\n              })),\n              target: {\n                url: target.url\n              }\n            });\n          })\n        };\n      // falls through\n\n      case 6:\n        exportData = {\n          version: 7,\n          backups: exportData.backups.map((_ref6) => {\n            var _target$url;\n\n            let {\n              target\n            } = _ref6,\n                backup = _objectWithoutProperties(_ref6, [\"target\"]);\n\n            return _objectSpread(_objectSpread({}, backup), {}, {\n              targets: [{\n                url: (_target$url = target.url) !== null && _target$url !== void 0 ? _target$url : \"\"\n              }]\n            });\n          })\n        };\n      // falls through\n\n      case 7:\n        for (const backup of exportData.backups) {\n          await this.saveBackup(_objectSpread(_objectSpread({}, backup), {}, {\n            name: await this.getSafeBackupName(backup.name),\n            id: undefined\n          }));\n        }\n\n    }\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"backups\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return [];\n  }\n})), _class);","map":{"version":3,"sources":["/home/runner/work/site/site/modules/database/backup/BackupManager.ts"],"names":["observable","runInAction","downloadBlob","toSnakeCase","messageOf","BackupManager","constructor","databaseManager","editorManager","initialized","then","loadBackupList","catch","backups","cursor","database","transaction","objectStore","index","openKeyCursor","push","id","primaryKey","name","key","continue","getId","getKey","loadBackup","backup","get","set","messages","map","data","message","targets","target","fetch","saveBackup","files","undefined","reference","url","put","deleteBackup","delete","exportBackup","backupData","version","blob","Blob","JSON","stringify","type","exportAll","openCursor","value","getSafeBackupName","number","proposedName","importBackups","exportData","parse","text","webhookUrl"],"mappings":"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","sourcesContent":["/* eslint-disable no-await-in-loop */\n\nimport { observable, runInAction } from \"mobx\"\nimport { downloadBlob } from \"../../../common/dom/downloadBlob\"\nimport { toSnakeCase } from \"../../../common/object/toSnakeCase\"\nimport type { EditorManagerLike } from \"../../editor/EditorManager\"\nimport { messageOf } from \"../../message/helpers/messageOf\"\nimport type { MessageData } from \"../../message/state/data/MessageData\"\nimport type { DatabaseManager } from \"../DatabaseManager\"\nimport type { Backup } from \"./types/Backup\"\nimport type { BackupData } from \"./types/BackupData\"\nimport type { ExportData } from \"./types/ExportData\"\n\nexport class BackupManager {\n  private readonly databaseManager: DatabaseManager\n  private readonly editorManager: EditorManagerLike\n\n  @observable backups: BackupData[] = []\n\n  constructor(\n    databaseManager: DatabaseManager,\n    editorManager: EditorManagerLike,\n  ) {\n    this.databaseManager = databaseManager\n    this.editorManager = editorManager\n\n    databaseManager.initialized\n      .then(async () => {\n        await this.loadBackupList()\n      })\n      .catch(() => {})\n  }\n\n  private async loadBackupList() {\n    const backups: BackupData[] = []\n\n    let cursor = await this.databaseManager.database\n      .transaction(\"backup\")\n      .objectStore(\"backup\")\n      .index(\"name\")\n      .openKeyCursor()\n\n    while (cursor) {\n      backups.push({\n        id: cursor.primaryKey,\n        name: cursor.key,\n      })\n\n      cursor = await cursor.continue()\n    }\n\n    runInAction(() => {\n      this.backups = backups\n    })\n  }\n\n  private async getId(name: string) {\n    return this.databaseManager.database\n      .transaction(\"backup\")\n      .objectStore(\"backup\")\n      .index(\"name\")\n      .getKey(name)\n  }\n\n  async loadBackup(name: string) {\n    const backup = await this.databaseManager.database\n      .transaction(\"backup\")\n      .objectStore(\"backup\")\n      .index(\"name\")\n      .get(name)\n\n    if (!backup) return\n\n    this.editorManager.set(\n      \"messages\",\n      backup.messages.map(({ data, ...message }) => ({\n        ...messageOf(data),\n        ...message,\n      })),\n    )\n    this.editorManager.set(\"targets\", backup.targets)\n    for (const target of this.editorManager.targets) {\n      target.fetch().catch(() => {})\n    }\n  }\n\n  async saveBackup(backup: string | Backup) {\n    if (typeof backup === \"string\") {\n      const id = await this.getId(backup)\n\n      backup = {\n        id,\n        name: backup,\n        messages: this.editorManager.messages.map(message => ({\n          data: {\n            ...message.data,\n            files: undefined,\n          },\n          reference: message.reference,\n        })),\n        targets: this.editorManager.targets.map(target => ({\n          url: target.url,\n        })),\n      }\n    } else {\n      backup = {\n        ...backup,\n        id: await this.getId(backup.name),\n      }\n    }\n\n    if (!backup.id) delete backup.id\n\n    await this.databaseManager.database\n      .transaction(\"backup\", \"readwrite\")\n      .objectStore(\"backup\")\n      .put(backup)\n\n    await this.loadBackupList()\n  }\n\n  async deleteBackup(name: string) {\n    const id = await this.getId(name)\n    if (!id) return\n\n    await this.databaseManager.database\n      .transaction(\"backup\", \"readwrite\")\n      .objectStore(\"backup\")\n      .delete(id)\n\n    await this.loadBackupList()\n  }\n\n  async exportBackup(name: string) {\n    const backup = await this.databaseManager.database\n      .transaction(\"backup\")\n      .objectStore(\"backup\")\n      .index(\"name\")\n      .get(name)\n\n    if (!backup) return\n\n    const backupData: ExportData = {\n      version: 7,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      backups: [backup].map(({ id, ...backup }) => backup),\n    }\n\n    const blob = new Blob([JSON.stringify(backupData, undefined, 2), \"\\n\"], {\n      type: \"application/json\",\n    })\n\n    downloadBlob(blob, `${name}.json`)\n  }\n\n  async exportAll() {\n    const backups: Backup[] = []\n\n    let cursor = await this.databaseManager.database\n      .transaction(\"backup\")\n      .objectStore(\"backup\")\n      .openCursor()\n\n    while (cursor) {\n      backups.push({\n        ...cursor.value,\n        id: undefined,\n      })\n\n      cursor = await cursor.continue()\n    }\n\n    const backupData: ExportData = {\n      version: 7,\n      backups,\n    }\n\n    const blob = new Blob([JSON.stringify(backupData, undefined, 2), \"\\n\"], {\n      type: \"application/json\",\n    })\n\n    downloadBlob(blob, \"backups.json\")\n  }\n\n  private async getSafeBackupName(name: string) {\n    if (!(await this.getId(name))) {\n      return name\n    }\n\n    for (let number = 1; true; number++) {\n      const proposedName = `${name} (${number})`\n\n      if (!(await this.getId(proposedName))) {\n        return proposedName\n      }\n    }\n  }\n\n  async importBackups(blob: Blob) {\n    let exportData = JSON.parse(await blob.text()) as ExportData\n\n    switch (exportData.version) {\n      case 1:\n      case 2: {\n        exportData = {\n          version: 3,\n          backups: [\n            {\n              name: exportData.name,\n              message: toSnakeCase(exportData.message) as MessageData,\n            },\n          ],\n        }\n      }\n      // falls through\n      case 3: {\n        exportData = {\n          version: 4,\n          backups: exportData.backups.map(({ message, ...backup }) => ({\n            ...backup,\n            messages: [message],\n          })),\n        }\n      }\n      // falls through\n      case 4:\n        exportData = {\n          version: 5,\n          backups: exportData.backups.map(({ webhookUrl, ...backup }) => ({\n            ...backup,\n            target: {\n              url: webhookUrl,\n            },\n          })),\n        }\n      // falls through\n      case 5:\n        exportData = {\n          version: 6,\n          backups: exportData.backups.map(\n            ({ messages, target, ...backup }) => ({\n              ...backup,\n              messages: messages.map(data => ({\n                data,\n                reference: target.message,\n              })),\n              target: {\n                url: target.url,\n              },\n            }),\n          ),\n        }\n      // falls through\n      case 6:\n        exportData = {\n          version: 7,\n          backups: exportData.backups.map(({ target, ...backup }) => ({\n            ...backup,\n            targets: [{ url: target.url ?? \"\" }],\n          })),\n        }\n      // falls through\n      case 7:\n        for (const backup of exportData.backups) {\n          await this.saveBackup({\n            ...backup,\n            name: await this.getSafeBackupName(backup.name),\n            id: undefined,\n          })\n        }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}