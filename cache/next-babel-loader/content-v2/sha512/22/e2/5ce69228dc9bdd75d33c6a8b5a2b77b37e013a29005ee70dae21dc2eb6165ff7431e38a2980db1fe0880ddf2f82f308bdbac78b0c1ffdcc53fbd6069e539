{"ast":null,"code":"/* eslint-disable import/no-cycle */\nimport { types } from \"mobx-state-tree\";\nimport { delay } from \"../../common/state/delay\";\nimport { MessageModel } from \"../message/state/models/MessageModel\";\nimport { WebhookModel } from \"../webhook/WebhookModel\";\nexport const EditorManager = types.model(\"EditorManager\", {\n  messages: types.array(types.late(() => MessageModel)),\n  targets: types.array(types.late(() => WebhookModel))\n}).actions(self => ({\n  set(key, value) {\n    self[key] = value;\n  },\n\n  clear() {\n    self.messages.clear();\n    self.messages.push(MessageModel.create());\n  },\n\n  async save() {\n    for (const target of self.targets) {\n      for (const message of self.messages) {\n        const headers = {\n          \"Accept\": \"application/json\",\n          \"Accept-Language\": \"en\"\n        };\n        const body = message.body;\n\n        if (typeof body === \"string\") {\n          headers[\"Content-Type\"] = \"application/json\";\n        }\n        /* eslint-disable no-await-in-loop */\n\n\n        const [method, url] = await target.getRoute(message.reference);\n        const response = await fetch(url, {\n          method,\n          headers,\n          body\n        });\n        const data = await response.json();\n\n        if (response.headers.get(\"X-RateLimit-Remaining\") === \"0\") {\n          var _response$headers$get;\n\n          const retryAfter = Number((_response$headers$get = response.headers.get(\"X-RateLimit-Reset-After\")) !== null && _response$headers$get !== void 0 ? _response$headers$get : 2) * 1000;\n          console.log(\"Rate limited: delaying next request by\", retryAfter, \"milliseconds\");\n          await delay(retryAfter);\n        }\n        /* eslint-enable no-await-in-loop */\n\n\n        console.log(\"Target executed\", data);\n      }\n    }\n\n    return null;\n  },\n\n  async process(path) {\n    const match = /^\\/targets\\/(\\d+)\\/url$/.exec(path);\n\n    if (match) {\n      var _target$exists;\n\n      const target = self.targets[Number(match[1])];\n      await target.fetch();\n\n      if ((_target$exists = target.exists) !== null && _target$exists !== void 0 ? _target$exists : true) {\n        return {\n          errorValidations: [{\n            id: \"target\",\n            messages: []\n          }]\n        };\n      }\n\n      return {\n        errorValidations: [{\n          id: \"target\",\n          messages: [{\n            path,\n            message: \"Webhook does not exist\"\n          }]\n        }]\n      };\n    }\n\n    return {};\n  }\n\n})); // eslint-disable-next-line @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions","map":{"version":3,"sources":["/home/runner/work/site/site/modules/editor/EditorManager.ts"],"names":["types","delay","MessageModel","WebhookModel","EditorManager","model","messages","array","late","targets","actions","self","set","key","value","clear","push","create","save","target","message","headers","body","method","url","getRoute","reference","response","fetch","data","json","get","retryAfter","Number","console","log","process","path","match","exec","exists","errorValidations","id"],"mappings":"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","sourcesContent":["/* eslint-disable import/no-cycle */\n\nimport { Instance, SnapshotOrInstance, types } from \"mobx-state-tree\"\nimport { delay } from \"../../common/state/delay\"\nimport { MessageModel } from \"../message/state/models/MessageModel\"\nimport { WebhookModel } from \"../webhook/WebhookModel\"\n\nexport const EditorManager = types\n  .model(\"EditorManager\", {\n    messages: types.array(types.late(() => MessageModel)),\n    targets: types.array(types.late(() => WebhookModel)),\n  })\n  .actions(self => ({\n    set<K extends keyof typeof self>(\n      key: K,\n      value: SnapshotOrInstance<typeof self[K]>,\n    ) {\n      self[key] = value\n    },\n\n    clear() {\n      self.messages.clear()\n      self.messages.push(MessageModel.create())\n    },\n\n    async save() {\n      for (const target of self.targets) {\n        for (const message of self.messages) {\n          const headers: Record<string, string> = {\n            \"Accept\": \"application/json\",\n            \"Accept-Language\": \"en\",\n          }\n\n          const body = message.body\n          if (typeof body === \"string\") {\n            headers[\"Content-Type\"] = \"application/json\"\n          }\n\n          /* eslint-disable no-await-in-loop */\n\n          const [method, url] = await target.getRoute(message.reference)\n\n          const response = await fetch(url, { method, headers, body })\n          const data = await response.json()\n\n          if (response.headers.get(\"X-RateLimit-Remaining\") === \"0\") {\n            const retryAfter =\n              Number(response.headers.get(\"X-RateLimit-Reset-After\") ?? 2) *\n              1000\n\n            console.log(\n              \"Rate limited: delaying next request by\",\n              retryAfter,\n              \"milliseconds\",\n            )\n\n            await delay(retryAfter)\n          }\n\n          /* eslint-enable no-await-in-loop */\n\n          console.log(\"Target executed\", data)\n        }\n      }\n\n      return null\n    },\n\n    async process(path: string) {\n      const match = /^\\/targets\\/(\\d+)\\/url$/.exec(path)\n      if (match) {\n        const target = self.targets[Number(match[1])]\n\n        await target.fetch()\n        if (target.exists ?? true) {\n          return { errorValidations: [{ id: \"target\", messages: [] }] }\n        }\n\n        return {\n          errorValidations: [\n            {\n              id: \"target\",\n              messages: [{ path, message: \"Webhook does not exist\" }],\n            },\n          ],\n        }\n      }\n\n      return {}\n    },\n  }))\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions\nexport interface EditorManagerLike extends Instance<typeof EditorManager> {}\n"]},"metadata":{},"sourceType":"module"}