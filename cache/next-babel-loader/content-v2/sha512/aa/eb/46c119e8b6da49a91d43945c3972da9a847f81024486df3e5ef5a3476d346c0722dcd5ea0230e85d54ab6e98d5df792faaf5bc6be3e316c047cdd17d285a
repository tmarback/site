{"ast":null,"code":"/* eslint-disable import/no-cycle */\nimport { types } from \"mobx-state-tree\";\nimport { delay } from \"../../common/state/delay\";\nimport { MessageModel } from \"../message/state/models/MessageModel\";\nimport { WebhookModel } from \"../webhook/WebhookModel\";\nexport const EditorManager = types.model(\"EditorManager\", {\n  messages: types.array(types.late(() => MessageModel)),\n  targets: types.array(types.late(() => WebhookModel))\n}).actions(self => ({\n  set(key, value) {\n    self[key] = value;\n  },\n\n  clear() {\n    self.messages.clear();\n    self.messages.push(MessageModel.create());\n  },\n\n  async save() {\n    for (const target of self.targets) {\n      for (const message of self.messages) {\n        const headers = {\n          \"Accept\": \"application/json\",\n          \"Accept-Language\": \"en\"\n        };\n        const body = message.body;\n\n        if (typeof body === \"string\") {\n          headers[\"Content-Type\"] = \"application/json\";\n        }\n        /* eslint-disable no-await-in-loop */\n\n\n        const [method, url] = await target.getRoute(message.reference);\n        const response = await fetch(url, {\n          method,\n          headers,\n          body\n        });\n        const data = await response.json();\n\n        if (response.headers.get(\"X-RateLimit-Remaining\") === \"0\") {\n          var _response$headers$get;\n\n          const retryAfter = Number((_response$headers$get = response.headers.get(\"X-RateLimit-Reset-After\")) !== null && _response$headers$get !== void 0 ? _response$headers$get : 2) * 1000;\n          console.log(\"Rate limited: delaying next request by\", retryAfter, \"milliseconds\");\n          await delay(retryAfter);\n        }\n        /* eslint-enable no-await-in-loop */\n\n\n        console.log(\"Target executed\", data);\n      }\n    }\n\n    return null;\n  },\n\n  async process(path) {\n    const match = /^\\/targets\\/(\\d+)\\/url$/.exec(path);\n\n    if (match) {\n      var _target$exists;\n\n      const target = self.targets[Number(match[1])];\n      await target.fetch();\n\n      if ((_target$exists = target.exists) !== null && _target$exists !== void 0 ? _target$exists : true) {\n        return {\n          errorValidations: [{\n            id: \"target\",\n            messages: []\n          }]\n        };\n      }\n\n      return {\n        errorValidations: [{\n          id: \"target\",\n          messages: [{\n            path,\n            message: \"Webhook does not exist\"\n          }]\n        }]\n      };\n    }\n\n    return {};\n  }\n\n})); // eslint-disable-next-line @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions","map":null,"metadata":{},"sourceType":"module"}